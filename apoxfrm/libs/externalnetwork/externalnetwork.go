package externalnetwork

import (
	"fmt"
	"strings"

	"github.com/mitchellh/mapstructure"
	"go.aporeto.io/gaia"
)

// Decode a gaia.ExternalNetwork from a map. Also performs sanity checks.
func Decode(e map[string]interface{}) (*gaia.ExternalNetwork, error) {

	extnet := gaia.NewExternalNetwork()
	if err := mapstructure.Decode(e, extnet); err != nil {
		return nil, err
	}

	if extnet.Type != gaia.ExternalNetworkTypeSubnet {
		return nil, fmt.Errorf("unhandled external network type")
	}

	return extnet, nil
}

// Transform a gaia.ExternalNetwork to a v2 version.
func Transform(extnet *gaia.ExternalNetwork, migrationSuffix, extnetPrefix string) *gaia.ExternalNetwork {

	// Process the external network - Create a v2 copy, add suffix to name, remove protocol and ports
	v2extnet := extnet.DeepCopy()
	v2extnet.Name = v2extnet.Name + migrationSuffix
	v2extnet.ServicePorts = []string{}
	associatedTags := []string{}
	for _, t := range v2extnet.AssociatedTags {
		if strings.HasPrefix(t, extnetPrefix) {
			t = t + migrationSuffix
		}
		associatedTags = append(associatedTags, t)
	}
	v2extnet.AssociatedTags = associatedTags
	return v2extnet
}

// Encode a gaia.ExternalNetwork into a map.
func Encode(e *gaia.ExternalNetwork) (map[string]interface{}, error) {

	xe := map[string]interface{}{}
	if err := mapstructure.Decode(e, &xe); err != nil {
		return nil, err
	}

	for k, v := range xe {
		keySpec := e.SpecificationForAttribute(strings.ToLower(k))
		if !keySpec.Exposed || keySpec.ReadOnly || keySpec.Autogenerated || v == keySpec.DefaultValue {
			delete(xe, k)
		}
	}

	return xe, nil
}
